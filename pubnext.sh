#!/bin/sh
# script to generate HTML and text (Gopher) file from Markdown formatted text
# and to send e-mails containing both to a list of recipients
# (2015 YCB)
myself=`basename "$0"`
mydir=`dirname "$0"`
ver='1.1'
subpref='[newsletter]' # prefix for mail subject
tpref='t' # prefix for text file names
adds='ad.txt' # address list for recipients
webdir='' # directory to save result from HTML conversion
gopherdir='' # directory to save result from text conversion
draft='DRAFT' # mark for draft texts (must be at beginning of one line)
arch='Archiv' # archive directory for processed texts
htmlhead='<HTML><BODY>'
htmlfoot="</BODY><!-- generated by $myself --></HTML>"

# in general, nothing should be modified below this line
lockf='.pubnext.lock' # lockfile
logfile='.pubnext.log'
convert1="$mydir/mrkdwn.pl" # markdown to HTML converter
convert2='lynx -display_charset=US-ASCII -force-html -dump' # HTML to text
mailer=mailx # mail program
#mailer='logit ::' # dummy for testing
tmpf1='.pubnext.html'
tmpf2='.pubnext.txt'
donefile='' # name of sent file

# if no argument given, print usage information
if test "$1" = ""
then cat <<EOH >&2

usage: $myself <dir> [<prefix> <addressfile> <webdir> <gopherdir>]
 will change to directory <dir>, and send first <text> with <prefix> to all
 addresses in <addressfile>,
 after Markdown conversion with $convert1
 (adding html&body tags for standalone HTML file),
 and HTML-text conversion with $convert2,
 and copy the text to <webdir> as HTML and to <gopherdir> as pure text
 (with .html/.txt suffixes, respectively, ignoring nonexistent directories),
 and do "git mv <text> $arch" afterwards (or just "mv", unless .git present)

 only texts not containing "$draft" at beginning of lines will be considered

 defaults: prefix=$tpref
  addressfile=$adds
  webdir=$webdir
  gopherdir=$gopherdir

 addressfile contains one address per line, lines with leading # are ignored

 return value 0 if <text> found and processed, >0 otherwise
 (logging into $logfile, lockfile $lockf)
 (version $ver, 2015 YCB)

EOH
exit 1
fi

logit () { echo "$@" >>$logfile ; }

abort () { # end script and remove lockfile, if return code higher than 9
 exc=$1
 shift
 logit "abort: $@" # log all remaining arguments
 if test $exc -gt 9 # if first arg>9
 then rm -f $lockf
 fi
 # report to stdout, will generate e-mail if launched by cronjob
 echo "tail $logfile:"
 tail $logfile
 exit $exc
}

dir="$1" # working directory
# if it's not a directory where we can execute and write and read
if test ! -x "$dir" -o ! -w "$dir" -o ! -r "$dir" -o ! -d "$dir"
then abort 5 "$dir is not a fully accessible directory"
fi

cd "$dir"

# just fail if there is a lock file
# very dumb logic, could be improved with timeout and retry
if test -f $lockf
then abort 6 "lockfile $lockf exists"
fi

now=`date -u`
echo "lockfile for $myself with PID $$" >$lockf
echo "at $now" >>$lockf
echo >$tmpf1 # create empty file

logit starting at $now

tpref=${2:-$tpref}
logit looking for files with prefix $tpref
adds=${3:-$adds}
logit looking for mailing addresses in $adds

# only log if webdir or gopherdir are non-empty (ignore empty ones)
webdir=${4:-$webdir}
if test "$webdir" != ""
then logit directory for saving HTML files: $webdir
fi
gopherdir=${5:-$gopherdir}
if test "$gopherdir" != ""
then logit directory for saving text files: $gopherdir
fi

# try to update from remote repo
# very dumb, may fail spectacularly if git is not installed
git pull >/dev/null 2>&1

# process all files with names beginning with $tpref
ls -1 $tpref* | { while read fn
do
 if ! grep "^$draft" "$fn" >/dev/null 2>&1
 then # if no draft flag found in text
  logit processing $fn
  echo "$htmlhead" >$tmpf1 # start with HTML file header
  # convert markdown to html, and replace German lower case umlauts (UTF8)
  # (might be improved with a separate character conversion list)
  $convert1 "$fn" |
   sed -e 's/ä/\&auml;/g;s/ö/\&ouml;/g;s/ü/\&uuml;/g' >>$tmpf1
  # get title from first <h1> header and remove all tags
  titl=`grep '<h1' $tmpf1 | head -n 1 | sed -e 's/<[^>]*>//g'`
  echo "$htmlfoot" >>$tmpf1 # finish with HTML footer
  # now generate text from HTML version
  $convert2 $tmpf1 >$tmpf2
  logit sending to
  # remove comments and empty lines from address list, and send e-mails
  sed -e 's/[ 	]*[#;].*//;/^$/d' $adds | { while read adrow
   do logit : $adrow
   $mailer -a $tmpf1 -s "$subpref $titl" $adrow <$tmpf2
   done
   }
  # remove suffix from filename
  namebase=${fn%.*}
  # copy HTML version into webdir and make world readable
  if test "$webdir" != ""
  then
   cat $tmpf1 >$webdir/$namebase.html 2>/dev/null &&
     chmod a+r $webdir/$namebase.html 2>/dev/null
  fi
  # copy text version into gopherdir and make world readable
  if test "$gopherdir" != ""
  then
   cat $tmpf2 >$gopherdir/$namebase.txt 2>/dev/null &&
     chmod a+r $gopherdir/$namebase.txt 2>/dev/null
  fi
  logit done with $fn
  # we are here in a subshell, therefore
  # save name of processed file for enclosing script
  # (at this point, we don't need $tmpf1 any more, therefore recycle)
  echo $fn >$tmpf1
  break
 else logit ignoring draft $fn
 fi
done
}

# get name of processed file
donefile=`cat $tmpf1`
if test ! -r "$donefile" # if that is not a readable file
then
 logit no file found and nothing processed
 retval=1 # return value FALSE if nothing processed
else
 retval=0 # else return value TRUE
 # try moving processed file with git into archive
 if git mv "$donefile" $arch >/dev/null 2>&1
 then logit git mv done
  # commit and push archived text file
  git commit -a -m ": $myself processing $donefile" >/dev/null 2>&1 && logit git commit done
  sleep 9 # wait a bit, to let file system finish its work after git
  git push >/dev/null 2>&1 && logit git push done
 else # simply use mv for archiving
  mv "$donefile" $arch && logit mv into $arch done
 fi
fi

rm -f $lockf
logit finished.
echo >>$logfile # empty line in logfile increases readability
exit $retval # report back return value: allpub.sh uses this for while-loop
